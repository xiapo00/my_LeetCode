这是刷题日记，可以直接通过Ctrl + F查找4位数题号快速找到所需题目的位置。

2020.04.04 晚上
今天于知乎听说Leetcode，相见恨晚，遂始尝试一简单题。
题目0001（Solution_0001）要求在数组（列表）中寻找和为给定值的两数。
一开始的想法自然是两个循环嵌套，但是如此一来时间复杂度就上去了——第一次提交耗时接近5秒。
第二个想法即使受了启发决定使用python自带的字典数据类型，以其快速索引的特点避免第二个循环。
结果于是十分理想，耗时不足50ms，效率提高了百倍。
后来经过一些简单命令的优化，达到了现在的40ms，击败了90%的用户。
并且，本次刷题时遇到的文件模板刷新了我对python类定义的认知——第一次见没有继承和__init__()的类。
算是开了好头，但是太晚了，还是睡觉为妙，往后多刷多练，益寿延年。

2020.04.05 早上
昨日一试，欲罢不能，今日继续。
最初苦于python没有指针可使用，查找了许久的相关资料，而后悟——自建对象的实例名可以当指针用。
题目0002（Solution_0002）要求返回两个输入的整数链表的整数的和的链表。（我tm在说啥？）
方法1失败，输入[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[5,6,4]时，
输出不正确，判断为int类型溢出，即题意不允许使用int加法实现，必须自底层实现单个数位的相加与进位。
计划下午或者晚上，先写个合适的测试函数，再作定夺。

2020.04.05 下午
查了一下，发现python的int类型是不会溢出的，至于问题出在什么地方，自然需要好好调试排查一下。
调通了，问题似乎出在int(n3 / 10)一句中，改成n3 // 10即可。（可能int类型不溢出，但int()函数会溢出？）
运行耗时击败了八成多的用户，但是内存消耗较高，排在了最高的5%里。还是可以改进的。晚上有空试试。

2020.04.05 晚上
在测试函数中编写了方便的int2ListNode()和ListNode2int()，可在测试函数内部直接调用。
可能有人觉得这个结构还挺蛋疼的，但思前想后，这是能想到的最好的结构了吧。
毕竟改进计划是基于单个数位的相加与进位的，这个函数还真只能在测试中用到了。
经过一轮紧张又刺激的调试，实现了改进计划了，然而如此跑出来的时间反而更长了，实在费解。
获得的经验也是有一点的，比如说使用(l1 and l1.next)来避免因l1为None或0引起的报错。
后试将方法1模块化，再提交发现用时也还是长了，与方法2相当，实在费解。
大概便是一日一题的速度？尝试明天按这个节奏把第0003题拿下。

2020.04.06 早上
题目0003要求返回给定字符串的最长无重复子串的长度。
网上将之归类为中等难度，但我有点没懂它比归类为简单的0001题难在什么地方。
想法是昨日将睡的时候便已经想到的，利用两个索引值（头、尾）确定一个子串，然后，
若生长（头不变尾加一）不引入重复，则生长；
若生长引入重复，则平移（头尾各加一）；
若平移后内部有重复，则继续平移；
当尾到字符串尽头则退出循环，此时的头尾距离就是这个最长子串的长度。
提交并运行之，耗时76ms，战胜了六成多的用户，于是图改进。
思路应该接近最简了，但是具体实现上应该还有改进的空间。
实验发现取set的长度一步耗时不低，计划于下午或晚上尝试改进一下。

2020.04.06 晚上
思前想后，莫得办法，改善作罢，另辟新题。
题目0004要求寻找两个有序数组的联合中位数，初看题目的思路自然是两数组各取索引，逐步比较，
数组一中者大则数组二的指针需推进一位；
否则数组二的指针推进一位，
两索引值之和达到两数组之和之一半的时候，即可求出中位数。
尝试后发现，这个想法其实还是比较难实现的，有许多细节的东西需要考虑，这个考虑不周也导致了三次提交报错。
最后用的暴力法，直接将两个数组先按顺序一个个地排成一个新数组，再取其中位数，这就不那么难了。
没想到成绩也还不错，60ms，击败七成多。
然后我就想，何不秀一波python的优越性，把自带的排序功能给用上？于是就有了方法二。
短短两行所向无敌，随手一提交，52ms，击败八成多。
而注释中的取中位数方法摘自网上，经测试性能不如自己写的，故不用。
至于流产的第一想法，耿耿于怀，希望明天能实现之。
理论上第一个想法的时间应该是60ms的一半左右，真能做出来怕是排名会超神。