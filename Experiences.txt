这是刷题日记，可以直接通过Ctrl + F查找4位数题号快速找到所需题目的位置。


2020.04.04 晚上
今天于知乎听说Leetcode，相见恨晚，遂始尝试一简单题。
题目0001（Solution_0001）要求在数组（列表）中寻找和为给定值的两数。
一开始的想法自然是两个循环嵌套，但是如此一来时间复杂度就上去了——第一次提交耗时接近5秒。
第二个想法即使受了启发决定使用python自带的字典数据类型，以其快速索引的特点避免第二个循环。
结果于是十分理想，耗时不足50ms，效率提高了百倍。
后来经过一些简单命令的优化，达到了现在的40ms，击败了90%的用户。
并且，本次刷题时遇到的文件模板刷新了我对python类定义的认知——第一次见没有继承和__init__()的类。
算是开了好头，但是太晚了，还是睡觉为妙，往后多刷多练，益寿延年。


2020.04.05 早上
昨日一试，欲罢不能，今日继续。
最初苦于python没有指针可使用，查找了许久的相关资料，而后悟——自建对象的实例名可以当指针用。
题目0002（Solution_0002）要求返回两个输入的整数链表的整数的和的链表。（我tm在说啥？）
方法1失败，输入[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[5,6,4]时，
输出不正确，判断为int类型溢出，即题意不允许使用int加法实现，必须自底层实现单个数位的相加与进位。
计划下午或者晚上，先写个合适的测试函数，再作定夺。


2020.04.05 下午
查了一下，发现python的int类型是不会溢出的，至于问题出在什么地方，自然需要好好调试排查一下。
调通了，问题似乎出在int(n3 / 10)一句中，改成n3 // 10即可。（可能int类型不溢出，但int()函数会溢出？）
运行耗时击败了八成多的用户，但是内存消耗较高，排在了最高的5%里。还是可以改进的。晚上有空试试。


2020.04.05 晚上
在测试函数中编写了方便的int2ListNode()和ListNode2int()，可在测试函数内部直接调用。
可能有人觉得这个结构还挺蛋疼的，但思前想后，这是能想到的最好的结构了吧。
毕竟改进计划是基于单个数位的相加与进位的，这个函数还真只能在测试中用到了。
经过一轮紧张又刺激的调试，实现了改进计划了，然而如此跑出来的时间反而更长了，实在费解。
获得的经验也是有一点的，比如说使用(l1 and l1.next)来避免因l1为None或0引起的报错。
后试将方法1模块化，再提交发现用时也还是长了，与方法2相当，实在费解。
大概便是一日一题的速度？尝试明天按这个节奏把第0003题拿下。


2020.04.06 早上
题目0003要求返回给定字符串的最长无重复子串的长度。
网上将之归类为中等难度，但我有点没懂它比归类为简单的0001题难在什么地方。
想法是昨日将睡的时候便已经想到的，利用两个索引值（头、尾）确定一个子串，然后，
若生长（头不变尾加一）不引入重复，则生长；
若生长引入重复，则平移（头尾各加一）；
若平移后内部有重复，则继续平移；
当尾到字符串尽头则退出循环，此时的头尾距离就是这个最长子串的长度。
提交并运行之，耗时76ms，战胜了六成多的用户，于是图改进。
思路应该接近最简了，但是具体实现上应该还有改进的空间。
实验发现取set的长度一步耗时不低，计划于下午或晚上尝试改进一下。


2020.04.06 晚上
思前想后，莫得办法，改善作罢，另辟新题。
题目0004要求寻找两个有序数组的联合中位数，初看题目的思路自然是两数组各取索引，逐步比较，
数组一中者大则数组二的指针需推进一位；
否则数组二的指针推进一位，
两索引值之和达到两数组之和之一半的时候，即可求出中位数。
尝试后发现，这个想法其实还是比较难实现的，有许多细节的东西需要考虑，这个考虑不周也导致了三次提交报错。
最后用的暴力法，直接将两个数组先按顺序一个个地排成一个新数组，再取其中位数，这就不那么难了。
没想到成绩也还不错，60ms，击败七成多。
然后我就想，何不秀一波python的优越性，把自带的排序功能给用上？于是就有了方法二。
短短两行所向无敌，随手一提交，52ms，击败八成多。
而注释中的取中位数方法摘自网上，经测试性能不如自己写的，故不用。
至于流产的第一想法，耿耿于怀，希望明天能实现之。
理论上第一个想法的时间应该是60ms的一半左右，真能做出来怕是排名会超神。


2020.04.07 早上
原来这个是困难题目，要求上还要求了时间复杂度，这么费劲。还是等日后水平成熟了再来回头优化好了。
题目0005要求返回一个字符串的最长回文子串。思路怕是和题目0003有点类似。
试了一下，屁嘞，类似个毛线。深入思考一下感觉双指针的办法已经没法实现了，因为写不出一个决定其进退的逻辑。
目前两种思路——一种暴力穷举，简单粗暴；另一种还是利用前面的生长、平移的思路。
第二种自然不好想，先把第一种搞出来看看时间排名怎么样再说。
提交了，平生第一次超出时间限制，哈哈哈哈哈，被一个1000个0的字符的输入打败了，败得惨烈，还差5个测试例就过了。
于是先行考虑了本来就是回文串的情况，直接输出，耗时砍下来了一点点，以6388ms通过了，击败了一成多用户，xswl。
原来有一成多的用户都是像我这样在超时的边缘徘徊的么😂
还是去换换脑子找找灵感再来优化了。


2020.04.07 晚上
回来写题了，显示看了一下官方的提示文档，然后决定在比较接近自己想法的动态规划方法上作优化并实现。
（卧槽原来这个算法叫这个名字）
定义一下初始化、生长、平移的方法：
1. 直接按官方文档，应先取一字符作为生长的中心，若其左右相等则往两端生长；
   直到左右不等则认为已经取到了以其为中心的最长回文子串。
2. 于是问题来了，以单个字符为中心的回文串必然是奇数个字符的，如此做法无法找到偶数个字符的回文子串。
   但问题也不大，因为偶数个字符的回文串，中心是两个相等的字符（暂称“字符偶”），故初始化的方法略改变即可。
3. 至于平移的方法，右派人士将选择逐位平移，即对所有的字符（偶）都寻找一遍以其为中心的字符串，必不遗漏。
   但是人不风流枉少年啊，爱拼才会赢啊，是不是应该想想更高效的办法？
   我猜想可以跳过已确认的回文串中的非心字符（偶），因为以非心字符（偶）为中心的回文串必没有之前确认的长。
   我就先试试，要是成功了就回来写个我这个猜想的证明过程，要是失败了就回来写个反例吧。
   （话说要是写证明的时候要插图，那用txt是不是不能很好地呈现？要不要把这个升级为markdown文档？）
哦豁，失败了，很致命的原理性错误。看来是必须当右派了。
ok，提交之，用时320ms，击败了近九成的用户，内存消耗也是正常范围内，感觉这东西很靠运气。
还不错啊今天，搞得颇有收获，唯一不爽的就是提交的时候错误了两次，提交正确率那边怕是要下降。
还是删点注释然后多提交一次，一来刷一下排名，二来刷一下正确率。[滑稽]
题目0001里一优化，二阶时间复杂度变成一阶，于是效率升了整整百倍；本题则效率提了20倍，可见复杂度是魔鬼啊。
也没想好明天是开新题还是学习旧题优秀代码，到时看心情吧。说不定到时心情好就不上LeetCode了呢？[滑稽]


2020.04.08 下午
没错，我跳题了。不是因为题目0006看着麻烦，而是因为题目0007看着简单，感觉十来分钟能整出来。
题目0007要求将输入的整数进行十进制的数位反转，目标清晰思路明确，边取输入的最低一位，边构造输出。
十来分钟果然写出来了，自己测试也没看出错，很是自信，提交之，报错，曰：溢出情况未处理好。
然后我就以为嘛，输入的数过大或过小的时候直接输出0就行，结果再提交，再错，说预期结果应该是0。
然后我又以为嘛，是这个写测试集的人瓦特了，于是把上下限按照报错的提示来修改了。
结果后来就遇到矛盾的地方，一个大的数都不溢出了，一个小点的数居然溢出了？
吃个饭回来才发现，原来还要考虑输出溢不溢出。于是给输出加了一步判断，提交就通过了。
48ms，其实还算不错的了，不过只击败了三成多的用户，略微改点地方，也没提升。我时间复杂度很低了啊？
结果看看评论和题解，发现好多人都是直接用字符串操作的，我就tmd。。。你管这叫写算法题？
然后顺便还改变了一下Solution中test()的写法，使添减测试数据更加方便。
顺带一提，预先算好2 ** 31的值有利于小幅提升效率。
明天要么做题目0007，要么试着改变一下以往的题目中test()的写法，到时看心情决定了。


2020.04.09 晚上
把test方法重写一下算了，今天滑个水。