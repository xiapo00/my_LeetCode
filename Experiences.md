这是刷题日记，可以直接通过Ctrl + F查找4位数题号快速找到所需题目的位置。

### 2020.04.04 晚上
今天于知乎听说Leetcode，相见恨晚，遂始尝试一简单题。<br>
[题目0001](https://leetcode-cn.com/problems/two-sum)要求在数组（列表）中寻找和为给定值的两数。<br>
一开始的想法自然是两个循环嵌套，但是如此一来时间复杂度就上去了——第一次提交耗时接近5秒。<br>
第二个想法即使受了启发决定使用python自带的字典数据类型，以其快速索引的特点避免第二个循环。<br>
结果于是十分理想，耗时不足50ms，效率提高了百倍。<br>
后来经过一些简单命令的优化，达到了现在的40ms，击败了90%的用户。<br>
并且，本次刷题时遇到的文件模板刷新了我对python类定义的认知——第一次见没有继承和__init__()的类。<br>
算是开了好头，但是太晚了，还是睡觉为妙，往后多刷多练，益寿延年。

### 2020.04.05 早上
昨日一试，欲罢不能，今日继续。<br>
最初苦于python没有指针可使用，查找了许久的相关资料，而后悟——自建对象的实例名可以当指针用。<br>
[题目0002](https://leetcode-cn.com/problems/add-two-numbers)（Solution_0002）要求返回两个输入的整数链表的整数的和的链表。（我tm在说啥？）<br>
方法1失败，输入[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[5,6,4]时，<br>
输出不正确，判断为int类型溢出，即题意不允许使用int加法实现，必须自底层实现单个数位的相加与进位。<br>
计划下午或者晚上，先写个合适的测试函数，再作定夺。

### 2020.04.05 下午
查了一下，发现python的int类型是不会溢出的，至于问题出在什么地方，自然需要好好调试排查一下。<br>
调通了，问题似乎出在int(n3 / 10)一句中，改成n3 // 10即可。（可能int类型不溢出，但int()函数会溢出？）<br>
运行耗时击败了八成多的用户，但是内存消耗较高，排在了最高的5%里。还是可以改进的。晚上有空试试。

### 2020.04.05 晚上
在测试函数中编写了方便的int2ListNode()和ListNode2int()，可在测试函数内部直接调用。<br>
可能有人觉得这个结构还挺蛋疼的，但思前想后，这是能想到的最好的结构了吧。<br>
毕竟改进计划是基于单个数位的相加与进位的，这个函数还真只能在测试中用到了。<br>
经过一轮紧张又刺激的调试，实现了改进计划了，然而如此跑出来的时间反而更长了，实在费解。<br>
获得的经验也是有一点的，比如说使用(l1 and l1.next)来避免因l1为None或0引起的报错。<br>
后试将方法1模块化，再提交发现用时也还是长了，与方法2相当，实在费解。<br>
大概便是一日一题的速度？尝试明天按这个节奏把第0003题拿下。

### 2020.04.06 早上
[题目0003](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters)要求返回给定字符串的最长无重复子串的长度。<br>
网上将之归类为中等难度，但我有点没懂它比归类为简单的0001题难在什么地方。<br>
想法是昨日将睡的时候便已经想到的，利用两个索引值（头、尾）确定一个子串，然后，<br>
若生长（头不变尾加一）不引入重复，则生长；<br>
若生长引入重复，则平移（头尾各加一）；<br>
若平移后内部有重复，则继续平移；<br>
当尾到字符串尽头则退出循环，此时的头尾距离就是这个最长子串的长度。<br>
提交并运行之，耗时76ms，战胜了六成多的用户，于是图改进。<br>
思路应该接近最简了，但是具体实现上应该还有改进的空间。<br>
实验发现取set的长度一步耗时不低，计划于下午或晚上尝试改进一下。

### 2020.04.06 晚上
思前想后，莫得办法，改善作罢，另辟新题。<br>
[题目0004](https://leetcode-cn.com/problems/median-of-two-sorted-arrays)要求寻找两个有序数组的联合中位数，初看题目的思路自然是两数组各取索引，逐步比较，<br>
数组一中者大则数组二的指针需推进一位；<br>
否则数组二的指针推进一位，<br>
两索引值之和达到两数组之和之一半的时候，即可求出中位数。<br>
尝试后发现，这个想法其实还是比较难实现的，有许多细节的东西需要考虑，这个考虑不周也导致了三次提交报错。<br>
最后用的暴力法，直接将两个数组先按顺序一个个地排成一个新数组，再取其中位数，这就不那么难了。<br>
没想到成绩也还不错，60ms，击败七成多。<br>
然后我就想，何不秀一波python的优越性，把自带的排序功能给用上？于是就有了方法二。<br>
短短两行所向无敌，随手一提交，52ms，击败八成多。<br>
而注释中的取中位数方法摘自网上，经测试性能不如自己写的，故不用。<br>
至于流产的第一想法，耿耿于怀，希望明天能实现之。<br>
理论上第一个想法的时间应该是60ms的一半左右，真能做出来怕是排名会超神。

### 2020.04.07 早上
原来这个是困难题目，要求上还要求了时间复杂度，这么费劲。还是等日后水平成熟了再来回头优化好了。<br>
[题目0005](https://leetcode-cn.com/problems/longest-palindromic-substring)要求返回一个字符串的最长回文子串。思路怕是和[题目0003](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters)有点类似。<br>
试了一下，屁嘞，类似个毛线。深入思考一下感觉双指针的办法已经没法实现了，因为写不出一个决定其进退的逻辑。<br>
目前两种思路——一种暴力穷举，简单粗暴；另一种还是利用前面的生长、平移的思路。<br>
第二种自然不好想，先把第一种搞出来看看时间排名怎么样再说。<br>
提交了，平生第一次超出时间限制，哈哈哈哈哈，被一个1000个0的字符的输入打败了，败得惨烈，还差5个测试例就过了。<br>
于是先行考虑了本来就是回文串的情况，直接输出，耗时砍下来了一点点，以6388ms通过了，击败了一成多用户，xswl。<br>
原来有一成多的用户都是像我这样在超时的边缘徘徊的么😂<br>
还是去换换脑子找找灵感再来优化了。

### 2020.04.07 晚上
回来写题了，显示看了一下官方的提示文档，然后决定在比较接近自己想法的动态规划方法上作优化并实现。<br>
（卧槽原来这个算法叫这个名字）<br>
定义一下初始化、生长、平移的方法：
1. 直接按官方文档，应先取一字符作为生长的中心，若其左右相等则往两端生长；<br>
   直到左右不等则认为已经取到了以其为中心的最长回文子串。<br>
2. 于是问题来了，以单个字符为中心的回文串必然是奇数个字符的，如此做法无法找到偶数个字符的回文子串。<br>
   但问题也不大，因为偶数个字符的回文串，中心是两个相等的字符（暂称“字符偶”），故初始化的方法略改变即可。<br>
3. 至于平移的方法，右派人士将选择逐位平移，即对所有的字符（偶）都寻找一遍以其为中心的字符串，必不遗漏。<br>
   但是人不风流枉少年啊，爱拼才会赢啊，是不是应该想想更高效的办法？<br>
   我猜想可以跳过已确认的回文串中的非心字符（偶），因为以非心字符（偶）为中心的回文串必没有之前确认的长。<br>
   我就先试试，要是成功了就回来写个我这个猜想的证明过程，要是失败了就回来写个反例吧。<br>
   （话说要是写证明的时候要插图，那用txt是不是不能很好地呈现？要不要把这个升级为markdown文档？）<br>

哦豁，失败了，很致命的原理性错误。看来是必须当右派了。<br>
ok，提交之，用时320ms，击败了近九成的用户，内存消耗也是正常范围内，感觉这东西很靠运气。<br>
还不错啊今天，搞得颇有收获，唯一不爽的就是提交的时候错误了两次，提交正确率那边怕是要下降。<br>
还是删点注释然后多提交一次，一来刷一下排名，二来刷一下正确率。[滑稽]<br>
[题目0001](https://leetcode-cn.com/problems/two-sum)里一优化，二阶时间复杂度变成一阶，于是效率升了整整百倍；本题则效率提了20倍，可见复杂度是魔鬼啊。<br>
也没想好明天是开新题还是学习旧题优秀代码，到时看心情吧。说不定到时心情好就不上LeetCode了呢？[滑稽]<br>

### 2020.04.08 下午
没错，我跳题了。不是因为[题目0006](https://leetcode-cn.com/problems/zigzag-conversion)看着麻烦，而是因为[题目0007](https://leetcode-cn.com/problems/reverse-integer)看着简单，感觉十来分钟能整出来。<br>
[题目0007](https://leetcode-cn.com/problems/reverse-integer)要求将输入的整数进行十进制的数位反转，目标清晰思路明确，边取输入的最低一位，边构造输出。<br>
十来分钟果然写出来了，自己测试也没看出错，很是自信，提交之，报错，曰：溢出情况未处理好。<br>
然后我就以为嘛，输入的数过大或过小的时候直接输出0就行，结果再提交，再错，说预期结果应该是0。<br>
然后我又以为嘛，是这个写测试集的人瓦特了，于是把上下限按照报错的提示来修改了。<br>
结果后来就遇到矛盾的地方，一个大的数都不溢出了，一个小点的数居然溢出了？<br>
吃个饭回来才发现，原来还要考虑输出溢不溢出。于是给输出加了一步判断，提交就通过了。<br>
48ms，其实还算不错的了，不过只击败了三成多的用户，略微改点地方，也没提升。我时间复杂度很低了啊？<br>
结果看看评论和题解，发现好多人都是直接用字符串操作的，我就tmd。。。你管这叫写算法题？<br>
然后顺便还改变了一下Solution中test()的写法，使添减测试数据更加方便。<br>
顺带一提，预先算好2 ** 31的值有利于小幅提升效率。<br>
明天要么做[题目0007](https://leetcode-cn.com/problems/reverse-integer)，要么试着改变一下以往的题目中test()的写法，到时看心情决定了。

### 2020.04.09 晚上
把test方法重写一下算了，今天滑个水。

### 2020.04.11 晚上
这水一滑就是三天，今天把之前的留的坑[题目0006](https://leetcode-cn.com/problems/zigzag-conversion)做了。[题目0006](https://leetcode-cn.com/problems/zigzag-conversion)要求返回将字符串按规定行数之字重排后的顺序结果。<br>
通过观察很容易想到通过索引值的余数判断并重排，于是写了个二阶复杂度的方法，通过了但耗时略有点高，需要另谋。<br>
然后我就把一个循环给省了下来，直接计算各个字符在重排中当居哪行，直接添加入该行的字符串里，最后整合。<br>
写完了提交，诶一跑就过了，耗时算挺低的，击败了近九成的用户，56ms，比之前方法的2568提升了近五十倍。

### 2020.04.13 晚上
来看看[题目0008](https://leetcode-cn.com/problems/string-to-integer-atoi/)，要求实现一个很诡异的功能，这atoi函数咱也不知道本来是干啥的。<br>
按题目要求归纳一下，应该是从字符串中提取有符号整数，但不太确定，怕是只能以可能多次提交失败为代价，完成这个题目了。<br>
思路呢，先去开头的空格，后找符号和数字，直至不是数字为止，将此切片的内容转为int，然后与上下限比较，而后输出。<br>
简单粗暴，但是也没有想到什么地方能讨巧。那就先写写试试吧，估计十来分钟怎么都写好了。<br>
第一次提交，发现漏了考虑输入'+'的情况，补上提交，就通过了。这就44ms，击败六成多用户了？也太水了吧。<br>
去了个忘记删掉的废命令，再提交一次，就变36ms了，击败九成多用户了。这就是所谓的中等难度，看来人间不值得啊~~<br>
看看官方的python题解，思想极其流啤，直接将空间复杂度控制到O(1)了，试着直接提交发现跑了80ms，击败一成不到hhh<br>
顺带一提，今天终于会用vscode自带的git工具了，就把那个sb一样的publish.bat去掉了。

### 2020.04.14 早上
看到[题目0009](https://leetcode-cn.com/problems/palindrome-number/submissions/)，甚是疑惑——内容乃是要求判断一个整数是否回文数。<br>
我估摸着可行，就把题目0007的方法直接拿来用了，结果就还通过了耗时84ms，击败五成多用户。<br>
又尝试直接以字符串翻转之术直接一行return，跑了跑耗时72ms，击败近八成用户。合着这12ms中间隔着两成人呢？呵。<br>
看题解也没看出什么花来，再刷也没意思了，毕竟简单题。过过过。

### 2020.04.24 下午
就是因为看到了[题目0010](https://leetcode-cn.com/problems/regular-expression-matching/)，我有十天都畏惧而没有做题。毕竟这个东西太难了啊。<br>
今天还是觉得，先python标准的正则匹配库试试水，看耗时大概多少，心里先略微有个谱。<br>
于是提交通过了，耗时76ms，击败六成用户，考虑到导入re库的耗时，实际耗时应该要更短一些。<br>
不过很疑惑，为什么这都能击败六成的用户啊？难道大家都不习惯先作弊通关再慢慢优化的吗🙃<br>
如今提交通过了，信心大增，欲自己实现这个功能还是有一点点思路了——首先必然是要将特殊字符与精准匹配的字符区分开来。<br>
不过看这题被标为“困难”，估摸着得调试半天，弄不好最后做不出来也说不定。等有空再把这个活整整好了。<br>
万一真整不出来，跳一下题，身为轻度强迫症患者也不至于太过难受，怎么说都算是有个通过记录了吧。

### 2020.04.25 晚上
明摆着这段时间就是划水。今日就是受了一点启发，决定要不以后test函数都通过面向对象的方式来完成？<br>
于是就定义了一个测试类，存放在[tester.py](tester.py)下，其中包括了初始化（需要函数、输入、输出集）和测试报错方法。<br>
然后就除了Solution_0002之外，都能用这个类来实现测试，而且代码更加简洁优美易读了，不能说是没有什么卵用。

### 2020.05.09 晚上
自从出了考研的复试线，自知一分之差未达线之后，一蹶不振，茶饭不思，自然也就没有来做题了。<br>
如今决定重新站起来了，故来挑战一下这个之前极为畏惧的题。假如能够解决出来，应该就能够真正振作起来了吧？<br>
还是要有思路，这首先应该是个动态规划的题目，需要两指针，分别在p和s中滑动计算。<br>
遇到p中的当前元素与s中的当前元素相同，则两个指针各进一位；遇到p中的.也是两个指针各进一位；<br>
遇到p中的\*则应将\*替换成\*的前一个字符+\*同时，直到\*后面的字符能匹配为止；<br>
若在中途任意位置匹配失败，则直接返回false；若能成功遍历整个字符串，则返回true。<br>
看起来哪里有点问题，是我陷入了死循环。还是先养精蓄锐，明天再试了。

### 2020.05.10 晚上
略作了一些关于指针跳动的修改，直接查看历史可自明，此不赘述。好不容易跑通了题目示例中提供的几个测试，提交之。<br>
于是就出了事，当输入为"mississippi", "mis*is*ip*."，结果应为True，然而我的程序出了False。让我看看哪出了问题。<br>
就在这千钧一发的时候，我的vscode调试模式的执行行显示秀逗了，瞎跳。很是悲哀啊，试试能不能整好，不能今天就到这吧。<br>
不能。ok。睡觉。

### 2020.05.11早上
换了个python版本就好了（3.8.2），于是就没有理由再逃避调试完善了。卒。（所以这是应该怪python3.7.6还是vscode？）<br>
盖之前的遍历结束后的判断有点问题，改掉就能通过现有测试集了。提交发现当输入为"ab", ".*c"，应为False，输出True。<br>
原来是匹配完ab之后，就跳出循环了，后面的判断也通过了，于是就输出了True。现在要想想，是不让之跳出循环恰当还是更改判断条件恰当？仔细想呢，这个p和s最好都能遍历完成，不然总是会出事的，这么说循环必须等到p和s都完成，那么必然面临的早被遍历完的字符串会有IndexError，这怎么处理还得好好想想。<br>
有个新的想法：\*是不能单独存在的，所以我们是不是应该把\*与其前一个字符凑成一个整体？<br>
如果是这样的话，可能要全盘改写了——整个思路都要重新设计。还是看看能不能在现有的框架上改进吧。

### 2020.05.11 晚上
我本轻度强迫症者，做题必以顺序，然时过境迁，今我欲开发一小应用，其中需要罗马数字转阿拉伯数字转的函数，故编之。<br>
编完发现原来在leetcode上这正好是[题目0013](https://leetcode-cn.com/problems/roman-to-integer/)，既然如此便顺便提交了罢。<br>
首先我们了解了罗马数字的规则——几个符号代表何等大小、在含4和9的数中有特殊表示。<br>
注意到若将特殊表示换为非特殊表示，则所有符号所表示的数之和即为整个罗马字符串所表示的数，那么程序上就按之而写。<br>
就先将特殊用法替换成非特殊的，然后在字典中查询逐个字符代表的数值，然后加起来，毫无难度。真不愧是简单题。<br>
提交了，同样的代码跑两次，一次耗时64ms，一次耗时52ms，击败近九成玩家。自我感觉也没什么优化的必要了。一气呵成。<br>
考虑到若在一个Solutions.py文件中写下所有的题解，将十分臃肿而不便阅读，故决定没10个题目分一个py文件。<br>
目录导航的地方也响应地作了更改，应该问题不大。先这么着试试。

试了下应该可以了，然后顺便把镜像题目[题目0012](https://leetcode-cn.com/problems/integer-to-roman/submissions/)给解决了。<br>
很显然本题应当在其下一题的基础上去反推——也就是说我的做题顺序是对的——所以有时候强行按顺序做也是会吃一点亏。<br>
思路就基本上是逆过程，要变通的是，罗马数字是从大的往小的写的，故应先试分解其为最大的罗马数字（即表示1000的M）;<br>
得到的余数再分解为第二大的罗马数字（即表示500的D）……以此类推，最后再将特殊的4和9的表示直接替换过来，就可以了。<br>
提交毫无悬念地通过，中等难度不过如此。第一次执行用时68ms，第二次执行勇士52ms，击败近九成用户。足矣足矣。<br>
很难得啊，一个晚上攻破了两个题目。接下来可以去尝试完成我的小应用了。<br>
话说这个思路的记录要不要也分没十个题一个文件啊？要是不分又太长，要是分了又不方便检索和题目之间对比。头大。<br>
只是改进一下tester就算了。新题目大概看了两眼，没什么思路。睡一觉估计可行。

### 2020.05.12 晚上
白天庸庸碌碌地过去，夜幕降临给我新的勇气。有些人仿佛天生就是黑夜的战士，只有在黑夜中他们头脑中的光芒才夺目起来。<br>
[题目0011](https://leetcode-cn.com/problems/container-with-most-water/)乃是难得一见的有应用背景的题目，于是有兴趣试试看。<br>
这个题，按人的思路应该先找最高的两个柱子，算一个面积；然后舍去最高的柱子，找剩余当中最高的两个，算一个面积……<br>
如是者直到所有的柱子都遍历到，就在所算得的面积中选取最大的一个，那个就是答案。<br>
想法是如此，但是一旦套用上题中所给的示例就出事了——示例中的柱子最高为8，有两个！于是最左一个有了不该有的优先级。<br>
所以要想想解决办法，比如说我们可以把所有的8与8间面积算出来、所有的8与7间面积也算出来……如此类推。试着实现一下。<br>
（途中手痒写了个暴力法，结果提交后在一个有5000项的超长输入的作用下毫无悬念超时了。但还是写下来吧。）<br>
实现了，被一个输入[1, 1]击败了。加一个简单的条件判断单独实现之即可。<br>
然后就被[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]给击败了。待老夫再debug一发。<br>
guigui，这tm是原理性错误啊，这个解应该是5~10装上水，所以根本不时出现在上面说到的两种情况之间。<br>
怎么办？全删掉重新写呗。妈的。思路倒是有一个新的。但是这这么长一段慢慢边试边写出来的，不忍心删掉啊。<br>
要不。。就留着？然后理一下新思路：首先假设只有最左边两根柱子，那么最多能装的水的面积显然数值等于柱子中较短者；<br>
现在来了第三根柱子，那么最多能装的水的面积无非两种情况——上一轮的结果、由上一轮的柱子和新柱子共同决定。来试试。<br>
难受啊，还是超时。这次是另一个5000项的输入。搞不懂这个题怎么有六成多的通过率。难道在计算机科班里这是经典题目么？<br>
思前想后，这个思路再往下怕是只有新增最大值的部分能优化了。比如说取最大值不用max([...])，而是手写一个。<br>
写了，根本无济于事，耗时也不见减少。想来想去原理上也没法简化了啊？这就很难受了。<br>
在放弃而取看题解之前，我还是用C语言写一遍暴力法，起码提交过了。而且方法三果然是比方法一快一点点哈。<br>
至于python的部分，可能还是看一看题解比较好。话说这么难搞的题怎么能算中等？？？<br>
原来是面试经典题，最优雅的做法是双指针，一般第一次见这个题的读者都想不到双指针的方法，而且有些结论还待证明。<br>
卧槽，按这个官方题解一写，一提交，只耗时60ms，击败了九成多的用户。反正一言以蔽之，你中途比较面积你复杂度就输了。<br>
看一下证明，意思是若移动双指针中较高者，必于事无补（宽度缩窄、高度不增），然而必须要要移一个，故移动较低者。<br>
还行，理解是能理解，自己想是想不到。长见识了。今天还知道了就是原来python真的很慢，粗测一下耗时大概是C的50倍。

### 2020.05.13 早上
这个[题目0014](https://leetcode-cn.com/problems/longest-common-prefix/)看着挺简单，我们来试它一试。<br>
要求直接标题自明——传入的列表中有若干个字符串，找一个最长公共前缀。思路也相应地就有——先假定第一个字符串即为所求；<br>
碰到下一个字符串，若发现不对了，那么就更新为新的公共前缀，遍历一遍应该就出来了。<br>
差不多，也就有一个特例[]没有考虑到，改一下就可以了，提交后运行耗时44ms，击败五成多。44ms算短的了吧？<br>
果然，再交一遍，40ms，就七成多了。看来这个题的排名就是看运气。果然，耗时28ms的用户其实算法跟我是一样的。<br>
唯一的区别就是他用str.find()是否为0的方法来判断是否前缀。我也试着改了一下，就变成了36ms了，超过近九成用户。<br>
这个题还算简单啊。初版十分钟，优化十分钟，就有个不错的结果了。这哪能算中等啊……

### 2020.05.13 中午
看到[题目0015](https://leetcode-cn.com/problems/3sum/)标题叫三数之和，马上想到leetcode[题目0001](https://leetcode-cn.com/problems/two-sum/)两数之和。<br>
这里要求三数之和是0，那么其实就是对于列表中的每一个数n，找另外两数之和为-n。但有两个地方难度提升了——<br>
一是这里的初试列表有重复元素，这在之前的两数之和中是不存在的；二是不允许有重复的三元组，因此最后要加一步去重。<br>
当务之急就先写好test函数，这个主要难在输出答案的不确定之外——两层列表中元素的顺序都是可以改变的。<br>
为了使得我们可以用tester里面的tester类来测试它，我们要将可变顺序的变成唯一的，方法自然就是两层排序。<br>
思路很清晰，代码很臃肿，最深处有七层括号，就问你怕不怕。测试过了测试函数是ok的（禁止套娃）。<br>
第一步是要先改进一下两数之和的函数。看了一下程序发现其实即使有重复也不怕——反正只输出最早出现的一对。<br>
谁说不怕的，提交之后才发现不对啊，只搞最早的一对当然不行！要jb全找出来！<br>
回去改进一下咯。略施小计解决了，但是当输入为3000个0的时候，超时了。这个好解决。<br>
提交了，耗时2712ms，击败了5%的用户。还行啦，东拼西凑出来一个东西，还能通过就不错了。<br>
复杂度应该就是在去重之前上去的，毕竟最最简单的用例重复都高得惊人——空间时间双复杂啊。<br>
不过还是要看看人家优秀的算法是怎么做的，毕竟有95%的用户成绩都比我的要好啊。扎心了扎心了扎心了……<br>
把最高赞的算法看了一下，思路也是定一个求另外两个，不过就不需要用别的花里胡哨算法来求，而是先排序再用双指针去找。<br>
有点意思哈，可能过几天有空试着实现一下？今天就算了，今天也算是做了两个题了，该去准备准备毕设和调剂的事情了。