这是刷题日记，可以直接通过Ctrl + F查找4位数题号快速找到所需题目的位置。

### 2020.04.04 晚上
今天于知乎听说Leetcode，相见恨晚，遂始尝试一简单题。<br>
[题目0001](https://leetcode-cn.com/problems/two-sum)要求在数组（列表）中寻找和为给定值的两数。<br>
一开始的想法自然是两个循环嵌套，但是如此一来时间复杂度就上去了——第一次提交耗时接近5秒。<br>
第二个想法即使受了启发决定使用python自带的字典数据类型，以其快速索引的特点避免第二个循环。<br>
结果于是十分理想，耗时不足50ms，效率提高了百倍。<br>
后来经过一些简单命令的优化，达到了现在的40ms，击败了90%的用户。<br>
并且，本次刷题时遇到的文件模板刷新了我对python类定义的认知——第一次见没有继承和__init__()的类。<br>
算是开了好头，但是太晚了，还是睡觉为妙，往后多刷多练，益寿延年。

### 2020.04.05 早上
昨日一试，欲罢不能，今日继续。<br>
最初苦于python没有指针可使用，查找了许久的相关资料，而后悟——自建对象的实例名可以当指针用。<br>
[题目0002](https://leetcode-cn.com/problems/add-two-numbers)（Solution_0002）要求返回两个输入的整数链表的整数的和的链表。（我tm在说啥？）<br>
方法1失败，输入[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[5,6,4]时，<br>
输出不正确，判断为int类型溢出，即题意不允许使用int加法实现，必须自底层实现单个数位的相加与进位。<br>
计划下午或者晚上，先写个合适的测试函数，再作定夺。

### 2020.04.05 下午
查了一下，发现python的int类型是不会溢出的，至于问题出在什么地方，自然需要好好调试排查一下。<br>
调通了，问题似乎出在int(n3 / 10)一句中，改成n3 // 10即可。（可能int类型不溢出，但int()函数会溢出？）<br>
运行耗时击败了八成多的用户，但是内存消耗较高，排在了最高的5%里。还是可以改进的。晚上有空试试。

### 2020.04.05 晚上
在测试函数中编写了方便的int2ListNode()和ListNode2int()，可在测试函数内部直接调用。<br>
可能有人觉得这个结构还挺蛋疼的，但思前想后，这是能想到的最好的结构了吧。<br>
毕竟改进计划是基于单个数位的相加与进位的，这个函数还真只能在测试中用到了。<br>
经过一轮紧张又刺激的调试，实现了改进计划了，然而如此跑出来的时间反而更长了，实在费解。<br>
获得的经验也是有一点的，比如说使用(l1 and l1.next)来避免因l1为None或0引起的报错。<br>
后试将方法1模块化，再提交发现用时也还是长了，与方法2相当，实在费解。<br>
大概便是一日一题的速度？尝试明天按这个节奏把第0003题拿下。

### 2020.04.06 早上
[题目0003](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters)要求返回给定字符串的最长无重复子串的长度。<br>
网上将之归类为中等难度，但我有点没懂它比归类为简单的0001题难在什么地方。<br>
想法是昨日将睡的时候便已经想到的，利用两个索引值（头、尾）确定一个子串，然后，<br>
若生长（头不变尾加一）不引入重复，则生长；<br>
若生长引入重复，则平移（头尾各加一）；<br>
若平移后内部有重复，则继续平移；<br>
当尾到字符串尽头则退出循环，此时的头尾距离就是这个最长子串的长度。<br>
提交并运行之，耗时76ms，战胜了六成多的用户，于是图改进。<br>
思路应该接近最简了，但是具体实现上应该还有改进的空间。<br>
实验发现取set的长度一步耗时不低，计划于下午或晚上尝试改进一下。

### 2020.04.06 晚上
思前想后，莫得办法，改善作罢，另辟新题。<br>
[题目0004](https://leetcode-cn.com/problems/median-of-two-sorted-arrays)要求寻找两个有序数组的联合中位数，初看题目的思路自然是两数组各取索引，逐步比较，<br>
数组一中者大则数组二的指针需推进一位；<br>
否则数组二的指针推进一位，<br>
两索引值之和达到两数组之和之一半的时候，即可求出中位数。<br>
尝试后发现，这个想法其实还是比较难实现的，有许多细节的东西需要考虑，这个考虑不周也导致了三次提交报错。<br>
最后用的暴力法，直接将两个数组先按顺序一个个地排成一个新数组，再取其中位数，这就不那么难了。<br>
没想到成绩也还不错，60ms，击败七成多。<br>
然后我就想，何不秀一波python的优越性，把自带的排序功能给用上？于是就有了方法二。<br>
短短两行所向无敌，随手一提交，52ms，击败八成多。<br>
而注释中的取中位数方法摘自网上，经测试性能不如自己写的，故不用。<br>
至于流产的第一想法，耿耿于怀，希望明天能实现之。<br>
理论上第一个想法的时间应该是60ms的一半左右，真能做出来怕是排名会超神。

### 2020.04.07 早上
原来这个是困难题目，要求上还要求了时间复杂度，这么费劲。还是等日后水平成熟了再来回头优化好了。<br>
[题目0005](https://leetcode-cn.com/problems/longest-palindromic-substring)要求返回一个字符串的最长回文子串。思路怕是和[题目0003](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters)有点类似。<br>
试了一下，屁嘞，类似个毛线。深入思考一下感觉双指针的办法已经没法实现了，因为写不出一个决定其进退的逻辑。<br>
目前两种思路——一种暴力穷举，简单粗暴；另一种还是利用前面的生长、平移的思路。<br>
第二种自然不好想，先把第一种搞出来看看时间排名怎么样再说。<br>
提交了，平生第一次超出时间限制，哈哈哈哈哈，被一个1000个0的字符的输入打败了，败得惨烈，还差5个测试例就过了。<br>
于是先行考虑了本来就是回文串的情况，直接输出，耗时砍下来了一点点，以6388ms通过了，击败了一成多用户，xswl。<br>
原来有一成多的用户都是像我这样在超时的边缘徘徊的么😂<br>
还是去换换脑子找找灵感再来优化了。

### 2020.04.07 晚上
回来写题了，显示看了一下官方的提示文档，然后决定在比较接近自己想法的动态规划方法上作优化并实现。<br>
（卧槽原来这个算法叫这个名字）<br>
定义一下初始化、生长、平移的方法：
1. 直接按官方文档，应先取一字符作为生长的中心，若其左右相等则往两端生长；<br>
   直到左右不等则认为已经取到了以其为中心的最长回文子串。<br>
2. 于是问题来了，以单个字符为中心的回文串必然是奇数个字符的，如此做法无法找到偶数个字符的回文子串。<br>
   但问题也不大，因为偶数个字符的回文串，中心是两个相等的字符（暂称“字符偶”），故初始化的方法略改变即可。<br>
3. 至于平移的方法，右派人士将选择逐位平移，即对所有的字符（偶）都寻找一遍以其为中心的字符串，必不遗漏。<br>
   但是人不风流枉少年啊，爱拼才会赢啊，是不是应该想想更高效的办法？<br>
   我猜想可以跳过已确认的回文串中的非心字符（偶），因为以非心字符（偶）为中心的回文串必没有之前确认的长。<br>
   我就先试试，要是成功了就回来写个我这个猜想的证明过程，要是失败了就回来写个反例吧。<br>
   （话说要是写证明的时候要插图，那用txt是不是不能很好地呈现？要不要把这个升级为markdown文档？）<br>

哦豁，失败了，很致命的原理性错误。看来是必须当右派了。<br>
ok，提交之，用时320ms，击败了近九成的用户，内存消耗也是正常范围内，感觉这东西很靠运气。<br>
还不错啊今天，搞得颇有收获，唯一不爽的就是提交的时候错误了两次，提交正确率那边怕是要下降。<br>
还是删点注释然后多提交一次，一来刷一下排名，二来刷一下正确率。[滑稽]<br>
[题目0001](https://leetcode-cn.com/problems/two-sum)里一优化，二阶时间复杂度变成一阶，于是效率升了整整百倍；本题则效率提了20倍，可见复杂度是魔鬼啊。<br>
也没想好明天是开新题还是学习旧题优秀代码，到时看心情吧。说不定到时心情好就不上LeetCode了呢？[滑稽]<br>

### 2020.04.08 下午
没错，我跳题了。不是因为[题目0006](https://leetcode-cn.com/problems/zigzag-conversion)看着麻烦，而是因为[题目0007](https://leetcode-cn.com/problems/reverse-integer)看着简单，感觉十来分钟能整出来。<br>
[题目0007](https://leetcode-cn.com/problems/reverse-integer)要求将输入的整数进行十进制的数位反转，目标清晰思路明确，边取输入的最低一位，边构造输出。<br>
十来分钟果然写出来了，自己测试也没看出错，很是自信，提交之，报错，曰：溢出情况未处理好。<br>
然后我就以为嘛，输入的数过大或过小的时候直接输出0就行，结果再提交，再错，说预期结果应该是0。<br>
然后我又以为嘛，是这个写测试集的人瓦特了，于是把上下限按照报错的提示来修改了。<br>
结果后来就遇到矛盾的地方，一个大的数都不溢出了，一个小点的数居然溢出了？<br>
吃个饭回来才发现，原来还要考虑输出溢不溢出。于是给输出加了一步判断，提交就通过了。<br>
48ms，其实还算不错的了，不过只击败了三成多的用户，略微改点地方，也没提升。我时间复杂度很低了啊？<br>
结果看看评论和题解，发现好多人都是直接用字符串操作的，我就tmd。。。你管这叫写算法题？<br>
然后顺便还改变了一下Solution中test()的写法，使添减测试数据更加方便。<br>
顺带一提，预先算好2 ** 31的值有利于小幅提升效率。<br>
明天要么做[题目0007](https://leetcode-cn.com/problems/reverse-integer)，要么试着改变一下以往的题目中test()的写法，到时看心情决定了。

### 2020.04.09 晚上
把test方法重写一下算了，今天滑个水。

### 2020.04.11 晚上
这水一滑就是三天，今天把之前的留的坑[题目0006](https://leetcode-cn.com/problems/zigzag-conversion)做了。[题目0006](https://leetcode-cn.com/problems/zigzag-conversion)要求返回将字符串按规定行数之字重排后的顺序结果。<br>
通过观察很容易想到通过索引值的余数判断并重排，于是写了个二阶复杂度的方法，通过了但耗时略有点高，需要另谋。<br>
然后我就把一个循环给省了下来，直接计算各个字符在重排中当居哪行，直接添加入该行的字符串里，最后整合。<br>
写完了提交，诶一跑就过了，耗时算挺低的，击败了近九成的用户，56ms，比之前方法的2568提升了近五十倍。

### 2020.04.13 晚上
来看看[题目0008](https://leetcode-cn.com/problems/string-to-integer-atoi/)，要求实现一个很诡异的功能，这atoi函数咱也不知道本来是干啥的。<br>
按题目要求归纳一下，应该是从字符串中提取有符号整数，但不太确定，怕是只能以可能多次提交失败为代价，完成这个题目了。<br>
思路呢，先去开头的空格，后找符号和数字，直至不是数字为止，将此切片的内容转为int，然后与上下限比较，而后输出。<br>
简单粗暴，但是也没有想到什么地方能讨巧。那就先写写试试吧，估计十来分钟怎么都写好了。<br>
第一次提交，发现漏了考虑输入'+'的情况，补上提交，就通过了。这就44ms，击败六成多用户了？也太水了吧。<br>
去了个忘记删掉的废命令，再提交一次，就变36ms了，击败九成多用户了。这就是所谓的中等难度，看来人间不值得啊~~<br>
看看官方的python题解，思想极其流啤，直接将空间复杂度控制到O(1)了，试着直接提交发现跑了80ms，击败一成不到hhh<br>
顺带一提，今天终于会用vscode自带的git工具了，就把那个sb一样的publish.bat去掉了。